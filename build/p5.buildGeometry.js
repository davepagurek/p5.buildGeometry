!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.GeometryBuilder=t():e.GeometryBuilder=t()}(self,(()=>(()=>{"use strict";var e={};return((e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.buildGeometry=t.GeometryBuilder=void 0;class r{constructor(e,t){this.p5=e,this.geometry=new e.constructor.Geometry(1,1),this.geometry.gid=t,this.stack=[new DOMMatrix],this.scratch=this.p5.createGraphics(1,1,this.p5.WEBGL);const r=this.scratch._renderer;r.drawBuffersScaled=(e,t,o,s)=>{const i=r.retainedMode.geometry[e].model;this.push(),this.scale(t,o,s),this.model(i),this.pop()},r.drawBuffers=e=>{const t=r.retainedMode.geometry[e].model;this.push(),this.applyMatrix(...r.uMVMatrix.mat4),this.model(t),this.pop()}}get(){return this.scratch.remove(),this.geometry}addGeometry(e){const t=this.geometry.vertices.length;this.geometry.vertices.push(...e.vertices.map((e=>{const t=this.transform().transformPoint(new DOMPoint(e.x,e.y,e.z,1));return this.p5.createVector(t.x,t.y,t.z)})));const r=this.normalMatrix();this.geometry.vertexNormals.push(...e.vertexNormals.map((e=>{const t=r.transformPoint(new DOMPoint(e.x,e.y,e.z,0));return this.p5.createVector(t.x,t.y,t.z)}))),this.geometry.faces.push(...e.faces.map((e=>e.map((e=>e+t))))),this.geometry.uvs.push(...e.uvs),this.geometry.edges.push(...e.edges.map((e=>e.map((e=>e+t)))));const o=[...e.vertexColors];for(;o.length<4*e.vertices.length;)o.push(...this.scratch._renderer.curFillColor);this.geometry.vertexColors.push(...o)}model(e){this.addGeometry(e)}beginShape(...e){this.scratch.beginShape(...e)}endShape(...e){this.scratch.endShape(...e);const t=this.scratch._renderer.immediateMode.geometry,r=[];if(this.scratch._renderer.immediateMode.shapeMode===this.p5.TRIANGLE_STRIP||this.p5.QUAD_STRIP)for(let e=2;e<t.vertices.length;e++)e%2==0?r.push([e,e-1,e-2]):r.push([e,e-2,e-1]);else for(let e=0;e<t.vertices.length;e+=3)r.push([e,e+1,e+2]);this.addGeometry(Object.assign(Object.assign({},t),{faces:r}))}vertex(...e){this.scratch.vertex(...e)}bezierVertex(...e){this.scratch.bezierVertex(...e)}quadraticVertex(...e){this.scratch.quadraticVertex(...e)}curveVertex(...e){this.scratch.curveVertex(...e)}curveTightness(...e){this.scratch.curveTightness(...e)}normal(...e){this.scratch.normal(...e)}fill(...e){this.scratch.fill(...e)}plane(...e){this.scratch.plane(...e)}box(...e){this.scratch.box(...e)}sphere(...e){this.scratch.sphere(...e)}cylinder(...e){this.scratch.cylinder(...e)}cone(...e){this.scratch.cone(...e)}torus(...e){this.scratch.torus(...e)}triangle(...e){this.scratch.triangle(...e)}ellipse(...e){this.scratch.ellipse(...e)}arc(...e){this.scratch.arc(...e)}rectMode(e){this.scratch.rectMode(e)}rect(...e){this.scratch.rect(...e)}quad(...e){this.scratch.quad(...e)}bezier(...e){this.scratch.bezier(...e)}curve(...e){this.scratch.curve(...e)}line(...e){this.scratch.line(...e)}transform(){return this.stack[this.stack.length-1]}normalMatrix(){const e=this.transform(),t=new DOMMatrix([e.m11,e.m12,e.m13,0,e.m21,e.m22,e.m23,0,e.m31,e.m32,e.m33,0,0,0,0,1]).inverse();return new DOMMatrix([t.m11,t.m21,t.m31,0,t.m12,t.m22,t.m32,0,t.m13,t.m23,t.m33,0,0,0,0,1])}push(){this.stack.push(DOMMatrix.fromMatrix(this.transform())),this.scratch.push()}pop(){if(this.stack.length<1)throw new Error("You called pop() but nothing was push()ed. Check that your push/pop calls are not mismatched.");this.stack.pop(),this.scratch.pop()}translate(e,t,r=0){this.transform().translateSelf(e,t,r)}scale(e,t,r){void 0===t&&void 0===r?(t=e,r=e):void 0===r&&(r=1),this.transform().scaleSelf(e,t,r)}rotate(e){this.rotateZ(e)}rotateX(e){this.transform().rotateSelf(e*(180/Math.PI),0,0)}rotateY(e){this.transform().rotateSelf(0,e*(180/Math.PI),0)}rotateZ(e){this.transform().rotateSelf(0,0,e*(180/Math.PI))}applyMatrix(...e){this.stack.pop(),this.stack.push(new DOMMatrix(e))}resetMatrix(){this.stack.pop(),this.stack.push(new DOMMatrix)}}function o(e){e.gid?this._renderer._freeBuffers(e.gid):console.error("The model you passed to freeModel does not have an id!")}function s(){this.shader(this._renderer._getImmediateModeShader())}function i(){this.shader(this._renderer._getVertexColorShader())}t.GeometryBuilder=r,t.buildGeometry=(e,t,o)=>{const s=new r(e,t);return o(s),s.get()},p5.prototype.buildGeometry=function(e,r){return(0,t.buildGeometry)(this,e,r)},p5.Graphics.prototype.buildGeometry=function(e,r){return(0,t.buildGeometry)(this,e,r)},p5.prototype.freeGeometry=o,p5.Graphics.prototype.freeGeometry=o,p5.prototype.flatModelColors=s,p5.Graphics.prototype.flatModelColors=s,p5.RendererGL.prototype._getVertexColorShader=function(){return this._vertexColorShader||(this._vertexColorShader=new p5.Shader(this,"\nprecision highp float;\nprecision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec4 aVertexColor;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Pass varyings to fragment shader\n  vViewPosition = viewModelPosition.xyz;\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  vNormal = uNormalMatrix * aNormal;\n  vTexCoord = aTexCoord;\n\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n  vAmbientColor *= aVertexColor.xyz;\n}\n",this._getLightShader()._fragSrc)),this._vertexColorShader},p5.prototype.shadedModelColors=i,p5.Graphics.prototype.shadedModelColors=i})(0,e),e})()));